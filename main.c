#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/start_bg.h"
#include "images/slayer.h"
#include "images/ghost1.h"
#include "images/ghost2.h"
#include "images/ghost3.h"
#include "images/battlefield.h"
#include "images/win_bg.h"
#include "images/lose_bg.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;
  startScreen();
  timer = 30;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
          if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY;
          playState();
        }
        break;
      case PLAY:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          timer = 30;
          startScreen();  
        } else if (die() == 1 || timer == 0) {
          state = LOSE;
          waitForVBlank();
          drawFullScreenImageDMA(lose_bg); //lose background if lose
        } else if (finishLine() == 1) {
          state = WIN;
          waitForVBlank();
          drawFullScreenImageDMA(win_bg); //win background if win
        } else {
          waitForVBlank();
          ghosts();
          slayerMovement(&currentButtons);
          timerFunc();
        }
        break;
      case WIN:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          timer = 30;
          startScreen();
          
        }
        break;
      case LOSE:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          timer = 30;
          startScreen();
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}

/**
 * Displays the inital start screen of the game.
*/
void startScreen(void) {
  vBlankCounter = 0;
  char starting[] = "ENTER";
  waitForVBlank();
  drawFullScreenImageDMA(start_bg);
  waitForVBlank();
  drawString(122, 105, starting, WHITE);
}

/**
 * The intial position of the characters in the play state.
*/
void playState(void) {
  waitForVBlank();
  drawFullScreenImageDMA(battlefield);
  waitForVBlank();
  slayers.x = 20;
  slayers.y = 0;
  ghost1s.x = randint(30,70);
  ghost1s.y = randint(30,80);
  
  ghost2s.x = randint(70,110);
  ghost2s.y = randint(90,150);
  ghost3s.x = randint(110,139);
  ghost3s.y = randint(160,220);
  drawImageDMA(slayers.x, slayers.y, SLAYER_WIDTH, SLAYER_HEIGHT, slayer);
  drawImageDMA(ghost1s.x, ghost1s.y, GHOST1_WIDTH, GHOST1_HEIGHT, ghost1);
  drawImageDMA(ghost2s.x, ghost2s.y, GHOST2_WIDTH, GHOST2_HEIGHT, ghost2);
  drawImageDMA(ghost3s.x, ghost3s.y, GHOST3_WIDTH, GHOST3_HEIGHT, ghost3);
  drawRectDMA(70, 225, 15, 15, BLUE);
  char timerArr[] = "Timer: "; //timer: 30 seconds
  char timerPrint[11];
  snprintf(timerPrint, 10, "%s%d\n", timerArr, timer);
  drawString(145, 0, timerPrint, CYAN);
}

/**
 * On-Screen timer - displays how many seconds are left
*/
void timerFunc(void) {
  if (vBlankCounter % 60 == 0) {
    undrawImageDMA(145, 0, 240, 8, battlefield);
    timer = timer - 1;
    char timerArr[] = "Timer: ";
    char timerPrint[11];
    int copyLength = 10;
    if (timer < 10) {
      copyLength--;
    }
    snprintf(timerPrint, copyLength, "%s%d\n", timerArr, timer);
    drawString(145, 0, timerPrint, CYAN);
  }
}


/**
 * Function for moving the slayer sprite
*/
void slayerMovement(u32 *pressedButtons) {
  int *row = &slayers.x;
  int *col = &slayers.y;
  int colDisp = 2;
    int rowDisp = 2;
  if (KEY_DOWN(BUTTON_RIGHT, *pressedButtons)) {
    undrawImageDMA(*row, *col, SLAYER_WIDTH, SLAYER_HEIGHT, battlefield);
    *col = *col + colDisp; // shift column
    if (*col > WIDTH - SLAYER_WIDTH) { // bounds checking for right
      *col = *col - colDisp;
    }
    drawImageDMA(*row, *col, SLAYER_WIDTH, SLAYER_HEIGHT, slayer);
  } else if (KEY_DOWN(BUTTON_LEFT, *pressedButtons)) {
    undrawImageDMA(*row, *col, SLAYER_WIDTH, SLAYER_HEIGHT, battlefield);
    *col = *col - colDisp; // shift column
    if (*col < 0) { // bounds checking for left
      *col = 0;
    }
    drawImageDMA(*row, *col, SLAYER_WIDTH, SLAYER_HEIGHT, slayer);
  } else if (KEY_DOWN(BUTTON_DOWN, *pressedButtons)) {
    undrawImageDMA(*row, *col, SLAYER_WIDTH, SLAYER_HEIGHT, battlefield);
    *row = *row + rowDisp; // shift row
    if (*row > 143 - SLAYER_HEIGHT) { // bounds checking for bottom
      *row = *row - rowDisp;
    }
    drawImageDMA(*row, *col, SLAYER_WIDTH, SLAYER_HEIGHT, slayer);
  } else if (KEY_DOWN(BUTTON_UP, *pressedButtons)) {
    undrawImageDMA(*row, *col, SLAYER_WIDTH, SLAYER_HEIGHT, battlefield);
    *row = *row - rowDisp; // shift row
    if (*row < 9) { // bounds checking for top
      *row = 9;
    }
    drawImageDMA(*row, *col, SLAYER_WIDTH, SLAYER_HEIGHT, slayer);
  } 
  
}

/**
 * Moves all the ghosts at once
*/
void ghosts(void) {
  moveGhost1();
  moveGhost2();
  moveGhost3();
}

/**
 * Moves ghost 1 in a random direction (up, down, left, or right)
*/
void moveGhost1(void) {
  static int direction = -1;   // current direction
  static int distance = 0;   // current distance moved in current direction
  static int maxDist = 30;  // max distance before changing direction
  static int minDisp = 1;   // min displacement
  static int maxDisp = 3;   // max displacement
  int *row = &ghost1s.x;
  int *col = &ghost1s.y;
  
  waitForVBlank();
  undrawImageDMA(*row, *col, GHOST1_HEIGHT, GHOST1_WIDTH, battlefield);
  
  if (direction == -1 || distance >= maxDist) { // choose a new direction
    direction = rand() % 4; // generate random number between 0 and 3
    distance = 0;
  }
  
  int disp = minDisp + distance * (maxDisp-minDisp) / maxDist; // current displacement
  
  switch(direction) {
    case 0:
      *row -= disp; // move up
      break;
    case 1:
      *row += disp; // move down
      break;
    case 2:
      *col -= disp; // move left
      break;
    case 3:
      *col += disp; // move right
      break;
  }
  
  if (*row > 139 - GHOST1_HEIGHT) { // bounds for bottom
    *row = 139 - GHOST1_HEIGHT;
    direction = -1; // choose a new direction
  } else if (*row < 30) { // bounds for top
    *row = 30;
    direction = -1; // choose a new direction
  }
  
  if (*col > 86 - GHOST1_WIDTH) { // bounds for right
    *col = 86 - GHOST1_WIDTH;
    direction = -1;   // choose a new direction
  } else if (*col < 27) { // bounds for left
    *col = 27;
    direction = -1; // choose a new direction
  }
  
  drawImageDMA(*row, *col, GHOST1_HEIGHT, GHOST1_WIDTH, ghost1);
  
  distance += disp; // update current distance moved
}





/**
 * Moves ghost 2 in a random direction (up, down, left, or right)
*/
void moveGhost2(void) {
  static int direction = -1; // current direction
  static int distance = 0; // current distance moved in current direction
  static int maxDist = 20; // max distance before changing direction
  static int minDisp = 1; // min displacement
  static int maxDisp = 3; // max displacement
  int *row = &ghost2s.x;
  int *col = &ghost2s.y;
  
  waitForVBlank();
  undrawImageDMA(*row, *col, GHOST2_HEIGHT, GHOST2_WIDTH, battlefield);
  
  if (direction == -1 || distance >= maxDist) { // choose a new direction
    direction = rand() % 4; // generate rand number between 0 and 3
    distance = 0;
  }
  
  int disp = minDisp + distance * (maxDisp-minDisp) / maxDist; // current displacement
  
  switch(direction) {
    case 0:
      *row -= disp; // move up
      break;
    case 1:
      *row += disp; // move down
      break;
    case 2:
      *col -= disp; // move left
      break;
    case 3:
      *col += disp; // move right
      break;
  }
  
  if (*row > 139 - GHOST2_HEIGHT) { // bounds for bottom
    *row = 139 - GHOST2_HEIGHT;
    direction = -1; // choose a new direction
  } else if (*row < 30) { // bounds for top
    *row = 30;
    direction = -1; // choose a new direction
  }
  
  if (*col > 153 - GHOST2_WIDTH) { // bounds for right
    *col = 153 - GHOST2_WIDTH;
    direction = -1; // choose a new direction
  } else if (*col < 87) { // bounds for left
    *col = 87;
    direction = -1; // choose a new direction
  }
  
  drawImageDMA(*row, *col, GHOST2_HEIGHT, GHOST2_WIDTH, ghost2);
  
  distance += disp; // update current distance moved
}


/**
 * Moves ghost 3 in a severely random direction (up, down, left, or right)
*/
void moveGhost3(void) {
  static int direction = -1; // current direction
  static int distance = 0; // current distance moved in current direction
  static int maxDist = 20; // max distance before changing direction
  static int minDisp = 1; // min displacement
  static int maxDisp = 3; // max displacement
  int *row = &ghost3s.x;
  int *col = &ghost3s.y;
  
  waitForVBlank();
  undrawImageDMA(*row, *col, GHOST3_HEIGHT, GHOST3_WIDTH, battlefield);
  
  if (direction == -1 || distance >= maxDist) { // choose a new direction
    direction = rand() % 4; // generate rand number between 0 and 3
    distance = 0;
  }
  
  int disp = minDisp + distance * (maxDisp-minDisp) / maxDist; // current displacement
  
  switch(direction) {
    case 0:
      *row -= disp; // move up
      break;
    case 1:
      *row += disp; // move down
      break;
    case 2:
      *col -= disp; // move left
      break;
    case 3:
      *col += disp; // move right
      break;
  }
  
  if (*row > 139 - GHOST3_HEIGHT) { // bounds for bottom
    *row = 139 - GHOST3_HEIGHT;
    direction = -1; // choose a new direction
  } else if (*row < 30) { // bounds for top
    *row = 30;
    direction = -1; // choose a new direction
  }
  
  if (*col > 220 - GHOST3_WIDTH) { // bounds for right
    *col = 220 - GHOST3_WIDTH;
    direction = -1; // choose a new direction
  } else if (*col < 154) { // bounds for left
    *col = 154;
    direction = -1; // choose a new direction
  }
  
  drawImageDMA(*row, *col, GHOST3_HEIGHT, GHOST3_WIDTH, ghost3);
  
  distance += disp; // update current distance moved
}


/**
 * The spaceship where the slayer has to go to in order to end the game.
*/
int finishLine(void) {
  int slayerRow = slayers.x;
  int slayerCol = slayers.y;
  int finishRow = 70;
  int finishCol = 225;
  if (slayerRow + SLAYER_WIDTH > finishRow && slayerRow < finishRow + 15) {
    if (slayerCol + SLAYER_HEIGHT > finishCol && slayerCol < finishCol + 15) {
      return 1;
    }
  }
  return 0;
}


/**
 * Checks if slayer touched a ghost, then the slayer dies (1).
 * If slayer doesn't touch any of the ghosts, it is still in the game (0).
*/
int die(void) {
  struct {int x; int y; int w; int h;} ghosts[] = {
    {ghost1s.x, ghost1s.y, GHOST1_WIDTH, GHOST1_HEIGHT},
    {ghost2s.x, ghost2s.y, GHOST2_WIDTH, GHOST2_HEIGHT},
    {ghost3s.x, ghost3s.y, GHOST3_WIDTH, GHOST3_HEIGHT}
  };
  for (int i = 0; i < 3; i++) {
    if (slayers.x + SLAYER_WIDTH > ghosts[i].x && slayers.x < ghosts[i].x + ghosts[i].w) {
      if (slayers.y + SLAYER_HEIGHT > ghosts[i].y && slayers.y < ghosts[i].y + ghosts[i].h) {
        return 1;
      }
    }
  }
  return 0;
}




